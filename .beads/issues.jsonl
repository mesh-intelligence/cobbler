{"id":"cobbler-mq5","title":"Cobbler Bootstrap","description":"Bootstrap cobbler project with documentation: VISION.md, ARCHITECTURE.md, and ROADMAP.yaml. Cobbler applies the autogenic systems pattern to software development. It is a dispatch layer that breaks work into small chunks and hands each to a specialized agent one-shot, avoiding iteration and saving tokens. Four self-* capabilities: self-orienting (measure - generate objectives), self-programming (stitch - synthesize behaviors), self-reflection (inspect/mend - evaluate reasoning), self-architecting (pattern - modify structure). Guided component model: human approves measure output before stitch executes. Agents are plug-and-play. Replaces prototype scripts (make-work.sh, do-work.sh).","status":"open","priority":2,"issue_type":"epic","owner":"petar.djukic@gmail.com","created_at":"2026-02-05T18:45:47.509775-05:00","created_by":"petardjukic","updated_at":"2026-02-05T22:35:04.813156-05:00"}
{"id":"cobbler-mq5.1","title":"Write VISION.md","description":"## Required Reading\n- .claude/rules/vision-format.md (format rule)\n- .claude/rules/documentation-standards.md (writing style)\n- .claude/rules/promt.md (Cupboard/Table design brief)\n- Bootstrap description in .claude/commands/bootstrap.md\n\n## Files to Create\n- docs/VISION.md\n\n## Requirements\n\nWrite VISION.md per vision-format rule.\n\nCobbler is NOT a coding agent or a planning agent. It is a dispatch layer that breaks work into small, well-defined chunks and hands each chunk to a specialized agent. The purpose is work breakdown: decompose large tasks into pieces small enough that an agent can execute each one without back-and-forth iteration. This saves tokens by avoiding long-running conversations where agents accumulate context, ask for clarification, or course-correct.\n\nCobbler applies the autogenic systems pattern to software development. Autogenic systems are systems that can generate their own goals, executable behaviors, and structural control logic. Cobbler implements the four autogenic self-* capabilities:\n\n1. Self-orienting: the system generates new objectives rather than only selecting from predefined goals. Where conventional systems optimize within fixed objectives, self-orienting systems redefine objectives and create new ones when required. In cobbler, \"measure\" analyzes the project state and proposes new tasks - it generates objectives, not just picks from a backlog.\n\n2. Self-programming: the system synthesizes new behaviors autonomously. Rather than only tuning parameters, self-programming generates procedural logic to realize novel objectives. In cobbler, \"stitch\" dispatches an agent to write docs or code - synthesizing new project behaviors.\n\n3. Self-reflection: the system evaluates its own reasoning processes and decision frameworks. Beyond measuring performance against fixed criteria, self-reflection examines and adapts the criteria themselves. In cobbler, \"inspect\" and \"mend\" evaluate output quality and fix issues - examining not just whether tests pass but whether the right tests exist.\n\n4. Self-architecting: the system modifies its core architecture and integrates new functionality at runtime. This includes synthesizing interface adaptors, restructuring components, and modifying protocols. In cobbler, \"pattern\" proposes changes to ARCHITECTURE, PRDs, and system structure.\n\nCobbler currently operates as a guided component: human-in-the-loop, where measure proposes and humans approve before stitch executes. The path toward recursive operation exists as confidence builds and solution patterns accumulate.\n\nThe command set uses shoemaking metaphors mapped to the self-* capabilities:\n\n| Self-capability | Command | Shoemaking | What it does |\n|----------------|---------|-----------|-------------|\n| Self-orienting | cobbler measure | Measure the foot | Generate new objectives by analyzing project state |\n| Self-programming | cobbler stitch | Elves sew the shoes | Dispatch agent to synthesize docs/code |\n| Self-reflection | cobbler inspect / cobbler mend | Check the seams / repair the sole | Evaluate output and adapt criteria |\n| Self-architecting | cobbler pattern | Draft the template | Propose structural and design changes |\n\nAgents are plug-and-play. Cobbler defines an agent interface; any LLM backend that implements it can be swapped in. A coding agent codes. A planning agent plans. Cobbler decides what to hand each agent and in what order.\n\nCobbler replaces prototype bash scripts (scripts/make-work.sh and scripts/do-work.sh) with a proper Go tool that has direct cupboard access via the crumbs Go module, structured prompt templates, and a real agent interface.\n\nSections to write:\n1. Executive Summary: cobbler is a dispatch layer that breaks work into small chunks and hands them to agents without iteration. Not an agent itself. Applies the autogenic systems pattern to software development. Four self-* capabilities. Not a task tracker, IDE plugin, or CI system.\n2. Introduction: context (AI agents are good at executing well-defined tasks but waste tokens when given large, ambiguous work). Problem (iterating directly with an agent on large tasks is token-inefficient). What cobbler does (decomposes work, prepares context, dispatches one-shot to agents). Introduce autogenic systems: systems that generate their own goals, behaviors, and structural logic. Cobbler applies this pattern to software development.\n3. Why this project: token efficiency through work breakdown. Applies autogenic systems research to software development tooling. Plug-and-play agent swapping. Graduates prototype scripts into a real tool. Fills the gap between task storage (crumbs) and agent execution.\n4. Planning and Implementation: success criteria (agents execute tasks without iteration; work is decomposed into chunks of appropriate size; guided component model with human approval), phases table (01.0 stitch docs, 02.0 stitch code, 03.0 measure, 04.0 inspect/mend/pattern), risks table.\n5. What This Is NOT: not a coding agent (agents code; cobbler dispatches). Not a planning agent (agents plan; cobbler decomposes). Not a task tracker (use crumbs). Not an IDE plugin. Not a CI system. Not an interactive agent session. Not a recursive component yet (guided, human-in-the-loop).\n\n## Acceptance Criteria\n- [ ] All required sections per vision-format present\n- [ ] Autogenic self-* capabilities defined with formal definitions (self-orienting generates objectives, self-programming synthesizes behaviors, self-reflection evaluates reasoning, self-architecting modifies structure)\n- [ ] Clear that cobbler is a dispatch layer, not an agent\n- [ ] Work breakdown as token efficiency mechanism explained\n- [ ] Guided component model (human approves measure output) explained\n- [ ] Plug-and-play agent swapping described\n- [ ] Command mapping to self-* capabilities and shoemaking metaphors\n- [ ] Origin story: replaces make-work.sh and do-work.sh prototype scripts\n- [ ] Style follows documentation-standards (active voice, no forbidden terms, royal we)\n- [ ] File saved as docs/VISION.md","status":"closed","priority":2,"issue_type":"task","owner":"petar.djukic@gmail.com","created_at":"2026-02-05T18:46:02.295666-05:00","created_by":"petardjukic","updated_at":"2026-02-05T22:34:24.631696-05:00","closed_at":"2026-02-05T20:58:29.426371-05:00","close_reason":"Closed","dependencies":[{"issue_id":"cobbler-mq5.1","depends_on_id":"cobbler-mq5","type":"parent-child","created_at":"2026-02-05T18:46:02.297302-05:00","created_by":"petardjukic"}]}
{"id":"cobbler-mq5.2","title":"Write ARCHITECTURE.md","description":"## Required Reading\n- docs/VISION.md (written in prior issue)\n- .claude/rules/architecture-format.md (format rule)\n- .claude/rules/documentation-standards.md (writing style)\n- .claude/rules/promt.md (Cupboard/Table design brief)\n- Crumbs docs: /Users/petardjukic/WORKSPACE/crumbs/docs/ARCHITECTURE.md (cupboard/table interfaces)\n- Crumbs PRDs: /Users/petardjukic/WORKSPACE/crumbs/docs/product-requirements/ (interface contracts)\n\n## Files to Create\n- docs/ARCHITECTURE.md\n\n## Requirements\n\nWrite ARCHITECTURE.md per architecture-format rule. Describe how cobbler is built: components, interfaces, data flow, and design decisions.\n\nCobbler applies the autogenic systems pattern to software development. It is a dispatch layer that breaks work into small chunks and dispatches each to an agent without iteration. The architecture must reflect both the autogenic framing and the practical dispatch model.\n\nAutogenic self-* capabilities and their architectural realization in cobbler:\n\n1. Self-orienting (cobbler measure): generates new objectives by analyzing project state (docs, roadmap, cupboard), identifying gaps, and proposing new tasks. Does not select from a fixed backlog - creates objectives. Replaces make-work.sh.\n\n2. Self-programming (cobbler stitch): synthesizes new behaviors by dispatching an agent to write docs or code. Agent receives a one-shot task with complete context and returns the result. No iteration. Replaces do-work.sh.\n\n3. Self-reflection (cobbler inspect / cobbler mend): evaluates output and reasoning. Inspect shows project state and evaluates what was produced. Mend dispatches agent to fix failing tests or lint - examining not just pass/fail but whether the right checks exist.\n\n4. Self-architecting (cobbler pattern): modifies project structure by dispatching agent to propose changes to ARCHITECTURE, PRDs, interfaces, and component organization.\n\nCobbler operates as a guided component: measure proposes, human approves, stitch executes. The guided/recursive distinction from autogenic systems research applies - cobbler starts guided and can progress toward recursive as confidence builds.\n\nCommands map to self-* capabilities:\n\n| Self-capability | Command | What it does |\n|----------------|---------|-------------|\n| Self-orienting | cobbler measure | Generate new objectives from project state |\n| Self-programming | cobbler stitch | Dispatch agent to synthesize docs/code one-shot |\n| Self-reflection | cobbler inspect / cobbler mend | Evaluate output, dispatch agent to fix |\n| Self-architecting | cobbler pattern | Dispatch agent to propose structural changes |\n\nSections to write:\n1. System Overview: cobbler applies the autogenic systems pattern to software development. It sits between crumbs cupboard and pluggable agents. Breaks work into small chunks and dispatches each one-shot. Guided component model (human-in-the-loop). Lifecycle (ready -\u003e claimed -\u003e context gathered -\u003e prompt built -\u003e agent dispatched one-shot -\u003e result -\u003e quality gate -\u003e closed). Pull-based coordination.\n2. Main interfaces: Cupboard integration (import crumbs Go module, Cupboard.GetTable(name).Get/Set), Agent interface (pluggable one-shot execution: agent receives prompt + tools, returns result; any LLM backend can be swapped in), Executor interface (claim, gather context, build prompt, dispatch one-shot, evaluate, close). Agent interface is the plug-and-play boundary.\n3. System Components: CLI (cobra, commands: measure, stitch, inspect, mend, pattern), Config (viper), Measure (self-orienting: reads project state, generates objectives - replaces make-work.sh), Stitch/Executor (self-programming: gathers context, dispatches agent one-shot - replaces do-work.sh), Inspect/Mend (self-reflection: evaluates output, dispatches fix), Pattern (self-architecting: proposes structural changes), Agent (pluggable LLM abstraction; Claude impl via anthropic-sdk-go), Prompt Builder (templates for one-shot dispatch), Crumbs Client (thin wrapper around crumbs Go module).\n4. Design Decisions: (a) autogenic systems pattern applied to software development, (b) work breakdown is the token efficiency mechanism - small tasks avoid iteration, (c) one-shot dispatch - no agent conversation, (d) guided component model - human approves measure output, (e) agent interface is plug-and-play boundary, (f) import crumbs as Go module, (g) commands named after shoemaking terms mapped 1:1 to self-* capabilities.\n5. Technology Choices: Go, cobra, viper, crumbs module (github.com/petar-djukic/crumbs), anthropic-sdk-go.\n6. Project Structure: cmd/cobbler/, pkg/ (agent, planner, executor, crumbs), internal/ (prompt, config, claude).\n7. Implementation Status: phase 01.0 focus is cobbler stitch --docs (self-programming for documentation).\n\n## Design Decisions\n- Autogenic systems pattern: four self-* capabilities realized as four commands\n- Guided component model: human-in-the-loop, measure proposes, human approves\n- Work breakdown for token efficiency: small one-shot tasks avoid iteration\n- Agent interface is the plug-and-play boundary: swap LLM backends\n- Prompt templates designed for one-shot execution: all context upfront\n- Cupboard via Go module import (github.com/petar-djukic/crumbs)\n- Shoemaking command names mapped 1:1 to autogenic self-* capabilities\n\n## Acceptance Criteria\n- [ ] All required sections per architecture-format present\n- [ ] Autogenic self-* capabilities mapped to architecture components\n- [ ] Formal self-* definitions used (generate objectives, synthesize behaviors, evaluate reasoning, modify structure)\n- [ ] Guided component model described\n- [ ] One-shot dispatch model clear - no agent iteration\n- [ ] Work breakdown as token efficiency mechanism\n- [ ] Agent interface as plug-and-play boundary\n- [ ] Command set documented with self-* mapping\n- [ ] Design decisions numbered with rationale\n- [ ] Technology choices table present\n- [ ] Project structure directory tree present\n- [ ] Style follows documentation-standards\n- [ ] File saved as docs/ARCHITECTURE.md","status":"closed","priority":2,"issue_type":"task","owner":"petar.djukic@gmail.com","created_at":"2026-02-05T18:46:21.116325-05:00","created_by":"petardjukic","updated_at":"2026-02-05T22:34:57.693781-05:00","closed_at":"2026-02-05T21:00:28.763235-05:00","close_reason":"Closed","dependencies":[{"issue_id":"cobbler-mq5.2","depends_on_id":"cobbler-mq5","type":"parent-child","created_at":"2026-02-05T18:46:21.117113-05:00","created_by":"petardjukic"},{"issue_id":"cobbler-mq5.2","depends_on_id":"cobbler-mq5.1","type":"blocks","created_at":"2026-02-05T18:46:21.118001-05:00","created_by":"petardjukic"}]}
{"id":"cobbler-mq5.3","title":"Write ROADMAP.yaml","description":"## Required Reading\n- docs/VISION.md (written in prior issue)\n- .claude/rules/use-case-format.md (release numbering scheme)\n\n## Files to Create\n- docs/ROADMAP.yaml\n\n## Requirements\n\nWrite ROADMAP.yaml as a YAML file defining the release schedule and use case status for cobbler.\n\nCommands use shoemaking terms mapped to autogenic self-* capabilities:\n- measure (self-orienting): assess state, propose tasks\n- stitch (self-programming): execute work via agents\n- inspect (self-reflecting): show project state\n- mend (self-reflecting): fix tests and lint\n- pattern (self-architecting): propose design changes\n\nReleases:\n- 00.0: Cross-release milestones (spans multiple releases)\n- 01.0: Core stitch (docs) - cobbler stitch --docs working end-to-end\n  - Use cases: cupboard connection, doc task execution, agent loop\n- 02.0: Core stitch (code) - cobbler stitch --code working\n  - Use cases: code task execution, quality gates (test, lint)\n- 03.0: Measure - cobbler measure working (replaces make-work.sh)\n  - Use cases: project analysis, work proposal, crumb creation\n- 04.0: Inspect, mend, and pattern - remaining self-* capabilities\n  - Use cases: project state display, test/lint fix loop, design proposals\n- 99.0: Unscheduled\n\nEach release entry should include: focus description, list of use cases with status (planned/in-progress/done), and deliverables.\n\n## Acceptance Criteria\n- [ ] YAML is valid and parseable\n- [ ] All releases listed with focus, use cases, and deliverables\n- [ ] Commands use revised names (measure, stitch, inspect, mend, pattern)\n- [ ] Release numbering matches use-case-format convention (NN.N)\n- [ ] File saved as docs/ROADMAP.yaml","status":"closed","priority":2,"issue_type":"task","owner":"petar.djukic@gmail.com","created_at":"2026-02-05T18:46:32.340903-05:00","created_by":"petardjukic","updated_at":"2026-02-05T21:01:26.396186-05:00","closed_at":"2026-02-05T21:01:26.396186-05:00","close_reason":"Closed","dependencies":[{"issue_id":"cobbler-mq5.3","depends_on_id":"cobbler-mq5","type":"parent-child","created_at":"2026-02-05T18:46:32.341608-05:00","created_by":"petardjukic"},{"issue_id":"cobbler-mq5.3","depends_on_id":"cobbler-mq5.1","type":"blocks","created_at":"2026-02-05T18:46:32.342535-05:00","created_by":"petardjukic"}]}
