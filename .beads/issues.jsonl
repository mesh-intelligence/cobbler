{"id":"cobbler-mq5","title":"Cobbler Bootstrap","description":"Bootstrap cobbler project with documentation: VISION.md, ARCHITECTURE.md, and ROADMAP.yaml. Cobbler is not a coding agent. It is a dispatch layer that breaks work into small, well-defined chunks and hands each chunk to a specialized agent as a one-shot task. This avoids iterating directly with agents, saving tokens. Agents are plug-and-play. Cobbler replaces prototype scripts (make-work.sh, do-work.sh) with a Go CLI structured around four autogenic self-* capabilities: self-orienting (measure), self-programming (stitch), self-reflecting (inspect/mend), and self-architecting (pattern).","status":"open","priority":2,"issue_type":"epic","owner":"petar.djukic@gmail.com","created_at":"2026-02-05T18:45:47.509775-05:00","created_by":"petardjukic","updated_at":"2026-02-05T21:58:10.454992-05:00"}
{"id":"cobbler-mq5.1","title":"Write VISION.md","description":"## Required Reading\n- .claude/rules/vision-format.md (format rule)\n- .claude/rules/documentation-standards.md (writing style)\n- .claude/rules/promt.md (Cupboard/Table design brief)\n- Bootstrap description in .claude/commands/bootstrap.md\n\n## Files to Create\n- docs/VISION.md\n\n## Requirements\n\nWrite VISION.md per vision-format rule.\n\nCobbler is NOT a coding agent or a planning agent. It is a dispatch layer that breaks work into small, well-defined chunks and hands each chunk to a specialized agent. The purpose is work breakdown: decompose large tasks into pieces small enough that an agent can execute each one without back-and-forth iteration. This saves tokens by avoiding long-running conversations where agents accumulate context, ask for clarification, or course-correct.\n\nWithout cobbler, an agent receives a large task, spends tokens orienting itself, iterates through misunderstandings, and burns context on task management. With cobbler, the agent gets a small, clear task with all the context it needs - no iteration required.\n\nAgents are plug-and-play. Cobbler defines an agent interface; any LLM backend that implements it can be swapped in. A coding agent codes. A planning agent plans. Cobbler decides what to hand each agent and in what order.\n\nCobbler replaces prototype bash scripts (scripts/make-work.sh and scripts/do-work.sh) with a proper Go tool that has direct cupboard access via the crumbs Go module, structured prompt templates, and a real agent interface.\n\nThe command set uses shoemaking metaphors mapped to autogenic self-* capabilities:\n\n| Self-capability | Command | What it does |\n|----------------|---------|-------------|\n| Self-orienting | cobbler measure | Assess project state, break down work into tasks |\n| Self-programming | cobbler stitch | Dispatch agent with a single well-defined task |\n| Self-reflecting | cobbler inspect / cobbler mend | Evaluate output, dispatch agent to fix issues |\n| Self-architecting | cobbler pattern | Dispatch agent to propose design changes |\n\nSections to write:\n1. Executive Summary: cobbler is a dispatch layer that breaks work into small chunks and hands them to agents without iteration. Not an agent itself. Four self-* capabilities. Not a task tracker, IDE plugin, or CI system.\n2. Introduction: context (AI agents are good at executing well-defined tasks but waste tokens when given large, ambiguous work that requires iteration). Problem (iterating directly with an agent on large tasks is token-inefficient; the agent spends tokens on orientation, clarification, and context accumulation rather than on execution). What cobbler does (breaks work down, prepares each chunk with the right context, dispatches to agents one-shot, sequences the results).\n3. Why this project: token efficiency through work breakdown and avoiding agent iteration. Plug-and-play agent swapping. Graduates prototype scripts into a real tool. Fills the gap between task storage (crumbs) and agent execution.\n4. Planning and Implementation: success criteria (agents execute tasks without iteration; work is decomposed into chunks of appropriate size), phases table (01.0 stitch docs, 02.0 stitch code, 03.0 measure, 04.0 inspect/mend/pattern), risks table.\n5. What This Is NOT: not a coding agent (agents code; cobbler dispatches). Not a planning agent (agents plan; cobbler decomposes). Not a task tracker (use crumbs). Not an IDE plugin. Not a CI system. Not an interactive agent session (cobbler avoids iteration by design).\n\n## Acceptance Criteria\n- [ ] All required sections per vision-format present\n- [ ] Clear that cobbler is a dispatch layer, not an agent\n- [ ] Work breakdown as the mechanism for token efficiency explained\n- [ ] Avoiding iteration with agents as a design goal explained\n- [ ] Plug-and-play agent swapping described\n- [ ] Autogenic self-* capabilities and command mapping explained\n- [ ] Origin story: replaces make-work.sh and do-work.sh prototype scripts\n- [ ] Style follows documentation-standards (active voice, no forbidden terms, royal we)\n- [ ] File saved as docs/VISION.md","status":"closed","priority":2,"issue_type":"task","owner":"petar.djukic@gmail.com","created_at":"2026-02-05T18:46:02.295666-05:00","created_by":"petardjukic","updated_at":"2026-02-05T21:58:29.222109-05:00","closed_at":"2026-02-05T20:58:29.426371-05:00","close_reason":"Closed","dependencies":[{"issue_id":"cobbler-mq5.1","depends_on_id":"cobbler-mq5","type":"parent-child","created_at":"2026-02-05T18:46:02.297302-05:00","created_by":"petardjukic"}]}
{"id":"cobbler-mq5.2","title":"Write ARCHITECTURE.md","description":"## Required Reading\n- docs/VISION.md (written in prior issue)\n- .claude/rules/architecture-format.md (format rule)\n- .claude/rules/documentation-standards.md (writing style)\n- .claude/rules/promt.md (Cupboard/Table design brief)\n- Crumbs docs: /Users/petardjukic/WORKSPACE/crumbs/docs/ARCHITECTURE.md (cupboard/table interfaces)\n- Crumbs PRDs: /Users/petardjukic/WORKSPACE/crumbs/docs/product-requirements/ (interface contracts)\n\n## Files to Create\n- docs/ARCHITECTURE.md\n\n## Requirements\n\nWrite ARCHITECTURE.md per architecture-format rule. Describe how cobbler is built: components, interfaces, data flow, and design decisions.\n\nCobbler is a dispatch layer that breaks work into small chunks and dispatches each to an agent without iteration. The architecture must reflect this: cobbler handles decomposition, context preparation, and sequencing. Agents receive one-shot tasks and return results. There is no back-and-forth conversation between cobbler and the agent during execution.\n\nCobbler replaces prototype scripts (scripts/make-work.sh -\u003e measure, scripts/do-work.sh -\u003e stitch) with a Go tool.\n\nCommands map to self-* capabilities:\n\n| Self-capability | Command | What it does |\n|----------------|---------|-------------|\n| Self-orienting | cobbler measure | Assess project state, decompose work into tasks |\n| Self-programming | cobbler stitch | Dispatch agent with a single well-defined task |\n| Self-reflecting | cobbler inspect / cobbler mend | Evaluate output, dispatch agent to fix |\n| Self-architecting | cobbler pattern | Dispatch agent to propose design changes |\n\nSections to write:\n1. System Overview: cobbler sits between crumbs cupboard and pluggable agents. It breaks work into small chunks and dispatches each to an agent as a one-shot task. No iteration with agents. Lifecycle of a work item (ready -\u003e claimed -\u003e context gathered -\u003e prompt built -\u003e agent dispatched one-shot -\u003e result received -\u003e quality gate -\u003e closed). Coordination pattern: pull-based (cobbler queries cupboard for ready crumbs).\n2. Main interfaces: Cupboard integration (import crumbs Go module, Cupboard.GetTable(name).Get/Set pattern), Agent interface (pluggable - one-shot execution: agent receives prompt + tools, returns result, no conversation; any LLM backend can be swapped in), Executor interface (claim, gather context, build prompt, dispatch one-shot, evaluate result, close). The agent interface is the plug-and-play boundary.\n3. System Components: CLI (cobra, commands: measure, stitch, inspect, mend, pattern), Config (viper), Measure (reads docs/roadmap/cupboard, decomposes work into small tasks - replaces make-work.sh), Executor/Stitch (gathers context, builds prompt, dispatches agent one-shot - replaces do-work.sh), Agent (LLM abstraction with pluggable backends; one-shot execution model; Claude impl via anthropic-sdk-go), Prompt Builder (templates that give agent everything it needs in one shot), Crumbs Client (thin wrapper around imported crumbs Go module).\n4. Design Decisions: (a) work breakdown is the token efficiency mechanism - small tasks avoid iteration, (b) one-shot dispatch model - agent receives complete context and returns result without conversation, (c) agent interface is the plug-and-play boundary - swap backends without changing dispatch logic, (d) import crumbs as Go module not CLI wrapper, (e) prompt templates designed to make one-shot execution possible (all context included), (f) commands named after shoemaking terms mapped to autogenic self-* capabilities.\n5. Technology Choices: Go, cobra, viper, crumbs module (github.com/petar-djukic/crumbs), anthropic-sdk-go.\n6. Project Structure: cmd/cobbler/, pkg/ (agent, planner, executor, crumbs), internal/ (prompt, config, claude).\n7. Implementation Status: phase 01.0 focus is cobbler stitch --docs.\n\n## Design Decisions\n- Work breakdown is the token efficiency mechanism: small, well-defined tasks avoid iteration\n- One-shot dispatch: agent receives complete context, returns result, no back-and-forth\n- Agent interface is the plug-and-play boundary: any LLM backend can be swapped in\n- Prompt templates designed for one-shot execution: agent gets everything it needs upfront\n- Cupboard accessed via imported Go module (github.com/petar-djukic/crumbs)\n- Command names from shoemaking trade mapped 1:1 to autogenic self-* capabilities\n\n## Acceptance Criteria\n- [ ] All required sections per architecture-format present\n- [ ] Clear that cobbler dispatches one-shot tasks, no agent iteration\n- [ ] Work breakdown described as the token efficiency mechanism\n- [ ] Agent interface described as plug-and-play boundary with one-shot model\n- [ ] Command set (measure, stitch, inspect, mend, pattern) documented with self-* mapping\n- [ ] Design decisions numbered with rationale\n- [ ] Technology choices table present\n- [ ] Project structure directory tree present\n- [ ] Style follows documentation-standards\n- [ ] File saved as docs/ARCHITECTURE.md","status":"closed","priority":2,"issue_type":"task","owner":"petar.djukic@gmail.com","created_at":"2026-02-05T18:46:21.116325-05:00","created_by":"petardjukic","updated_at":"2026-02-05T21:58:46.581853-05:00","closed_at":"2026-02-05T21:00:28.763235-05:00","close_reason":"Closed","dependencies":[{"issue_id":"cobbler-mq5.2","depends_on_id":"cobbler-mq5","type":"parent-child","created_at":"2026-02-05T18:46:21.117113-05:00","created_by":"petardjukic"},{"issue_id":"cobbler-mq5.2","depends_on_id":"cobbler-mq5.1","type":"blocks","created_at":"2026-02-05T18:46:21.118001-05:00","created_by":"petardjukic"}]}
{"id":"cobbler-mq5.3","title":"Write ROADMAP.yaml","description":"## Required Reading\n- docs/VISION.md (written in prior issue)\n- .claude/rules/use-case-format.md (release numbering scheme)\n\n## Files to Create\n- docs/ROADMAP.yaml\n\n## Requirements\n\nWrite ROADMAP.yaml as a YAML file defining the release schedule and use case status for cobbler.\n\nCommands use shoemaking terms mapped to autogenic self-* capabilities:\n- measure (self-orienting): assess state, propose tasks\n- stitch (self-programming): execute work via agents\n- inspect (self-reflecting): show project state\n- mend (self-reflecting): fix tests and lint\n- pattern (self-architecting): propose design changes\n\nReleases:\n- 00.0: Cross-release milestones (spans multiple releases)\n- 01.0: Core stitch (docs) - cobbler stitch --docs working end-to-end\n  - Use cases: cupboard connection, doc task execution, agent loop\n- 02.0: Core stitch (code) - cobbler stitch --code working\n  - Use cases: code task execution, quality gates (test, lint)\n- 03.0: Measure - cobbler measure working (replaces make-work.sh)\n  - Use cases: project analysis, work proposal, crumb creation\n- 04.0: Inspect, mend, and pattern - remaining self-* capabilities\n  - Use cases: project state display, test/lint fix loop, design proposals\n- 99.0: Unscheduled\n\nEach release entry should include: focus description, list of use cases with status (planned/in-progress/done), and deliverables.\n\n## Acceptance Criteria\n- [ ] YAML is valid and parseable\n- [ ] All releases listed with focus, use cases, and deliverables\n- [ ] Commands use revised names (measure, stitch, inspect, mend, pattern)\n- [ ] Release numbering matches use-case-format convention (NN.N)\n- [ ] File saved as docs/ROADMAP.yaml","status":"closed","priority":2,"issue_type":"task","owner":"petar.djukic@gmail.com","created_at":"2026-02-05T18:46:32.340903-05:00","created_by":"petardjukic","updated_at":"2026-02-05T21:01:26.396186-05:00","closed_at":"2026-02-05T21:01:26.396186-05:00","close_reason":"Closed","dependencies":[{"issue_id":"cobbler-mq5.3","depends_on_id":"cobbler-mq5","type":"parent-child","created_at":"2026-02-05T18:46:32.341608-05:00","created_by":"petardjukic"},{"issue_id":"cobbler-mq5.3","depends_on_id":"cobbler-mq5.1","type":"blocks","created_at":"2026-02-05T18:46:32.342535-05:00","created_by":"petardjukic"}]}
